---
title: "<Activity> krok po kroku"
pubDate: 2026-02-09
description: "Praktyczne wprowadzenie do <Activity> w React - jak wykorzysta je do budowania ultraszybkich interfejs贸w."
heroImage: "@assets/blog/react-activity/hero.png"
keywords:
  [
    "react",
    "activity",
    "react-19",
    "react-20",
  ]
tags: ["Frontend"]
---

## Co to Activity w React?

W nowoczesnych aplikacjach frontendowych wydajno interfejsu ma bezporedni wpyw na dowiadczenie u偶ytkownika. Ka偶de op贸藕nienie przy przeczaniu widok贸w, reset stanu formularzy czy ponowne renderowanie ci偶kich komponent贸w (tabele, wykresy, raporty) obni偶a pynno dziaania aplikacji.

**`<Activity>`** pozwala zachowa komponenty w pamici bez ich aktywnego renderowania. Zamiast `unmount --> mount`, React mo偶e je "upi", a nastpnie przywr贸ci w dokadnie tym samym stanie.

Dziki temu zyskujemy:

- brak utraty stanu komponentu,
- brak kosztownego ponownego renderowania,
- natychmiastowe przeczanie widok贸w.

Mo偶na traktowa to jak **cache dla UI**.

## R贸偶nica midzy Activity a display: none;

Czsto mo偶na spotka si z opini, 偶e `<Activity>` to po prostu alternatywa dla ukrywania element贸w za pomoc CSS. To nieporozumienie, r贸偶nica dotyczy caej architektury renderowania.

### display: none;

- element znika wizualnie
- React nadal traktuje go jako aktywny
- komponent nadal bierze udzia w re-renderach
- hooki (`useEffect`, `useLayoutEffect`) nadal dziaaj
- niepotrzebne zu偶ycie CPU i pamici

### Activity

- komponent jest ukryty logicznie, nie tylko wizualnie
- React obni偶a jego priorytet w schedulerze
- renderowanie i aktualizacje s wstrzymane
- efekty i hooki nie s wykonywane
- stan pozostaje zachowany w pamici



To fundamentalna r贸偶nica: **CSS ukrywa tylko wygld, Activity zatrzymuje prac komponentu.**

## Jak dziaa Activity?

Activity przyjmuje waciwo `mode`:

- `visible` - normalne renderowanie
- `hidden` - komponent zostaje "zamro偶ony"

W trybie `hidden` React:

- wstrzymuje efekty
- nie wykonuje aktualizacji
- nie przelicza renderu
- zachowuje stan, DOM i pozycj scrolla

Dziki temu powr贸t do widoku jest praktycznie natychmiastowy.


## Activity a cykl 偶ycia komponentu

* **Cleanup**: Wywoywane s funkcje czyszczce z `useEffect`, ale komponent nie jest odmontowywany.
* **State**: Stan komponentu jest zachowany
* **Re-mount**: Gdy tryb zmieni si na `visible`, efekty s ponownie uruchamiane, ale bez resetowania stanu.

Dziki temu nie musisz si martwi, 偶e "upiony" komponent w tle bdzie nadal utrzymywa otwarte poczenie WebSocket czy niepotrzebny timer.

## Gdzie to ma sens?

* Dashboardy i panele administracyjne (tabele, wykresy)
* Formularze wieloetapowe (zachowanie wpisanych danych)
* Nawigacja typu taby (szybkie przeczanie)
* Widoki prerenderowane w tle (przygotowanie ci偶kiego komponentu zanim u偶ytkownik go zobaczy)

## Przykady u偶ycia

### Dashboard z dwiema ci偶kimi tabelami

```tsx
import { Activity, useState } from 'react';

function Dashboard() {
  const [view, setView] = useState('sales');

  return (
    <section>
      <nav>
        <button onClick={() => setView('sales')}>Sprzeda偶</button>
        <button onClick={() => setView('inventory')}>Magazyn</button>
      </nav>

      <Activity mode={view === 'sales' ? 'visible' : 'hidden'}>
        <HeavyTable data={salesData} />
      </Activity>

      <Activity mode={view === 'inventory' ? 'visible' : 'hidden'}>
        <HeavyTable data={inventoryData} />
      </Activity>
    </section>
  );
}
```

Efekt: brak zbdnego renderowania, zachowany stan i byskawiczne przeczanie.

>  Wa偶na uwaga: Ka偶dy komponent w `<Activity mode="hidden">` nadal zajmuje pami RAM. Stosuj to rozwizanie dla kluczowych element贸w interfejsu, a nie dla ka偶dego komponentu w aplikacji.

## Prerenderowanie w tle

`<Activity>` w poczeniu z `<Suspense>` pozwala na renderowanie widok贸w w tle. Mo偶esz zaadowa dane i wyrenderowa ci偶ki komponent w trybie hidden. Gdy u偶ytkownik kliknie przycisk, komponent jest ju偶 "rozgrzany" i gotowy do natychmiastowego wywietlenia bez 偶adnych spinner贸w adowania.

## Podsumowanie

`<Activity>` pozwala utrzymywa widoki w pamici i kontrolowa ich aktywno zamiast montowa je od nowa. To prosta optymalizacja, kt贸ra znaczco poprawia responsywno aplikacji, szczeg贸lnie w dashboardach i rozbudowanych interfejsach.

Nale偶y pamita, 偶e `<Activity>` to nie tylko ukrywanie element贸w, ale przede wszystkim zarzdzanie ich cyklem 偶ycia i wydajnoci. Warto eksperymentowa z tym API, aby znale藕 najlepsze zastosowania w swoich projektach.

Moim zdaniem warto zacz si tym interesowa ju偶 teraz, poniewa偶 w przyszoci, gdy zostan dodane kolejne funkcjonalnoci, bdzie to kluczowy element optymalizacji interfejs贸w.